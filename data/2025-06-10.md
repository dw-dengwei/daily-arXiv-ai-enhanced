# ArXiv Daily Papers - 2025-06-10

## Total Papers Today: 3

<div id='toc'></div>

### Table of Contents
- [cs.LG](#cs.LG) [Total: 1]
- [nlin.CG](#nlin.CG) [Total: 1]
- [cs.CL](#cs.CL) [Total: 1]

## <div id='cs.LG'></div> cs.LG [[Back]](#toc)

### [1] [Extending AALpy with Passive Learning: A Generalized State-Merging Approach](http://arxiv.org/pdf/2506.06333v1)
> *使用被动学习扩展AALpy：一种广义状态合并方法*

*['Benjamin von Berg', 'Bernhard K. Aichernig']* | **Main category: {cate}**

**Keywords:** AALpy, 自动机学习, 状态合并, 被动学习, 红-蓝框架

**Comment:** Accepted for publication at CAV 2025, the 37th International
  Conference on Computer Aided Verification

> **TL;DR:** AALpy库通过广义状态合并方法扩展了被动学习功能，简化了状态合并算法的实现。

**AI_Comments:** 该工作通过在AALpy中引入通用的状态合并框架，显著提升了其在被动学习领域的应用能力，降低了算法实现的复杂度，具有较高的实用价值。

<details>
  <summary>Details</summary>

**Motivation:** 扩展AALpy库的功能，使其支持被动自动机学习中重要的状态合并方法。

**Method:** 在AALpy中实现了一个通用的、高度可配置的红-蓝框架状态合并方法，该方法使用通用的内部表示来处理不同类型的自动机。

**Result:** {result}

**Conclusion:** 通过AALpy实现状态合并算法，可以有效降低实现工作量，并促进现有和新型算法的实现。

> **ai_Abstract:** 本文介绍了AALpy库通过实现通用的红-蓝框架状态合并方法来扩展其被动学习功能。该方法利用通用内部表示处理不同类型的自动机，简化了状态合并算法的定义和执行，并通过少量代码实现了现有算法。

> **摘要翻译:** AALpy是一个成熟的开源自动机学习库，使用Python编写，专注于具有IO行为的系统的主动学习。它为不同类型的自动机提供了广泛的最新算法，范围从完全确定性到概率自动机。在这项工作中，我们介绍了最近添加的被动自动机学习领域中一种重要方法的广义实现：红-蓝框架中的状态合并。使用不同自动机类型的通用内部表示允许红-蓝框架的通用和高度可配置的实现。我们描述了如何使用AALpy定义和执行状态合并算法，这主要将状态合并算法的实现工作量减少到兼容性标准和评分的定义。这有助于实现现有和新型算法。特别是，使用AALpy定义文献中的一些现有状态合并算法只需几行代码。

</details>


## <div id='nlin.CG'></div> nlin.CG [[Back]](#toc)

### [2] [Elementary Cellular Automata as Non-Cryptographic Hash Functions](http://arxiv.org/pdf/2506.06551v1)
> *作为非密码散列函数的初等细胞自动机*

*['Daniel McKinley']* | **Main category: {cate}**

**Keywords:** 细胞自动机, 哈希函数, 误差最小化, 压缩算法, 边缘检测

**Comment:** 

> **TL;DR:** 初等细胞自动机（ECA）的子集被实现为哈希函数，使用误差最小化有损压缩算法。

**AI_Comments:** 该论文提出了一种新颖的哈希函数实现方法，利用了初等细胞自动机的特性。该方法具有一定的创新性，但其安全性和性能还需要进一步评估。

<details>
  <summary>Details</summary>

**Motivation:** 探索初等细胞自动机作为哈希函数的潜力。

**Method:** 使用误差最小化有损压缩算法在包裹的4x4邻域单元上实现10个初等细胞自动机（ECA）作为哈希函数。

**Result:** {result}

**Conclusion:** Not mentioned in abstract

> **ai_Abstract:** 本文提出了一种基于初等细胞自动机（ECA）的哈希函数实现方法，该方法利用误差最小化有损压缩算法处理4x4邻域单元。研究结果表明，部分ECA规则具有适用于哈希函数的特性，包括误差最小化、唯一解和高效追溯哈希。

> **摘要翻译:** 将256个初等细胞自动机（ECA）的一个子集中的10个实现为哈希函数，该哈希函数使用在包裹的4x4邻域单元上运行的误差最小化有损压缩算法。处理所有256条规则，发现两组8条规则中的10条规则具有误差最小化和最大化、唯一解、有损逆、高效追溯哈希以及边缘检测应用等属性。该算法与快速傅里叶变换和快速沃尔什-哈达玛变换的嵌套二次幂结构类似，用Java实现，旨在对任何2字节RGB代码位图进行哈希处理。

</details>


## <div id='cs.CL'></div> cs.CL [[Back]](#toc)

### [3] [Language Models over Canonical Byte-Pair Encodings](http://arxiv.org/pdf/2506.07956v1)
> *基于规范字节对编码的语言模型*

*['Tim Vieira', 'Tianyu Liu', 'Clemente Pasti', 'Yahya Emara', 'Brian DuSell', 'Benjamin LeBrun', 'Mario Giulianelli', 'Juan Luis Gastaldi', "Timothy J. O'Donnell", 'Ryan Cotterell']* | **Main category: {cate}**

**Keywords:** 语言模型, 字节对编码, 规范性

**Comment:** ICML 2025

> **TL;DR:** 语言模型会给不可能出现的token序列赋予非零概率，本文提出了两种方法来解决这个问题，并在实验中证明了其有效性。

**AI_Comments:** 本文创新性地提出了两种方法来解决语言模型中非规范token编码的问题，这对于提高语言模型的效率和准确性具有重要意义。该研究的局限性在于实验只在几个模型和语料库上进行，未来可以扩展到更多的模型和语料库上进行验证。

<details>
  <summary>Details</summary>

**Motivation:** 现有的语言模型会给每个字符序列的指数数量的非规范token编码赋予非零概率，这导致概率质量被浪费在不可能出现的输出上。

**Method:** 提出了两种方法来强制执行token级别语言模型中的规范性：(1) 通过条件作用实现规范性，利用测试时推理策略，无需额外训练；(2) 通过构造实现规范性，这是一种保证规范输出的模型参数化，但需要训练。

**Result:** {result}

**Conclusion:** 本文提出了两种方法来强制执行token级别语言模型中的规范性，实验表明修复规范性错误可以提高多个模型和语料库的保留数据的可能性。

> **ai_Abstract:** 本文提出了两种方法来解决语言模型中非规范token编码的问题，这些编码被赋予非零概率，导致概率质量的浪费。这两种方法分别是通过条件作用和通过构造实现规范性。实验结果表明，修复规范性错误可以提高模型的性能。

> **摘要翻译:** 现代语言模型将字符字符串上的概率分布表示为通过确定性分词器（如字节对编码）导出的（较短）token字符串上的分布。虽然这种方法在将语言模型扩展到大型语料库方面非常有效，但其目前的化身具有一个令人担忧的属性：该模型为每个字符字符串的指数数量的非规范token编码分配非零概率——这些token字符串解码为有效的字符字符串，但在确定性分词器下是不可能的（即，无论训练语料库有多大，它们都不会出现在任何训练语料库中）。这种错误分配既是错误的，因为非规范字符串永远不会出现在训练数据中，也是浪费的，将概率质量从合理的输出中转移出去。这些都是可以避免的错误！在这项工作中，我们提出了在token级别语言模型中强制执行规范性的方法，确保只有规范token字符串被分配正概率。我们提出了两种方法：（1）通过条件作用实现规范性，利用测试时推理策略，无需额外训练；（2）通过构造实现规范性，这是一种保证规范输出的模型参数化，但需要训练。我们证明了修复规范性错误可以提高多个模型和语料库的保留数据的可能性。

</details>
