# ArXiv Daily Papers - 2025-06-10

## Total Papers Today: 3

<div id='toc'></div>

### Table of Contents
- [cs.LG](#cs.LG) [Total: 1]
- [nlin.CG](#nlin.CG) [Total: 1]
- [cs.CL](#cs.CL) [Total: 1]

## <div id='cs.LG'></div> cs.LG [[Back]](#toc)

### [1] [Extending AALpy with Passive Learning: A Generalized State-Merging Approach](http://arxiv.org/pdf/2506.06333v1)
> *使用被动学习扩展AALpy：一种广义状态合并方法*

*['Benjamin von Berg', 'Bernhard K. Aichernig']* | **Main category: {cate}**

**Keywords:** AALpy, 状态合并, 被动学习, 自动机学习, red-blue框架

**Comment:** Accepted for publication at CAV 2025, the 37th International
  Conference on Computer Aided Verification

> **TL;DR:** {tldr}

**AI_Comments:** 该论文介绍了一种在AALpy库中实现被动学习的有效方法，通过广义状态合并，降低了算法实现的复杂度，具有一定的实用价值。

<details>
  <summary>Details</summary>

**Motivation:** 为了在AALpy库中加入被动自动机学习的重要方法：red-blue框架中的状态合并。

**Method:** 通过使用通用内部表示，实现red-blue框架的通用和高度可配置的实现，并描述如何使用AALpy定义和执行状态合并算法。

**Result:** {result}

**Conclusion:** AALpy库现在支持使用广义状态合并方法的被动学习，降低了算法的实现难度。

> **ai_Abstract:** 本文介绍了AALpy库通过实现广义状态合并方法扩展被动学习功能。该方法基于red-blue框架，并利用通用内部表示，简化了状态合并算法的定义和执行。实验结果表明，使用AALpy可以大大减少实现状态合并算法所需的代码量。

> **摘要翻译:** 

</details>


## <div id='nlin.CG'></div> nlin.CG [[Back]](#toc)

### [2] [Elementary Cellular Automata as Non-Cryptographic Hash Functions](http://arxiv.org/pdf/2506.06551v1)
> *作为非密码散列函数的初等元胞自动机*

*['Daniel McKinley']* | **Main category: {cate}**

**Keywords:** 元胞自动机, 散列函数, 误差最小化, 有损压缩, 边缘检测

**Comment:** 

> **TL;DR:** {tldr}

**AI_Comments:** 该论文探索了一种新颖的散列函数实现方式，将元胞自动机的特性应用于数据散列，具有一定的创新性。但其实用性和安全性还需要进一步评估。

<details>
  <summary>Details</summary>

**Motivation:** 探索初等元胞自动机在非密码散列函数中的应用。

**Method:** 实现了10个初等元胞自动机（ECA）的子集作为散列函数，使用误差最小化有损压缩算法处理4x4邻域单元。

**Result:** {result}

**Conclusion:** 该算法类似于快速傅里叶变换和快速Walsh-Hadamard变换的嵌套二次幂结构，用Java实现，旨在散列任何2字节RGB代码位图。

> **ai_Abstract:** 本文提出了一种使用初等元胞自动机（ECA）作为散列函数的方法。通过误差最小化有损压缩算法处理4x4邻域单元，实现了10个ECA子集。实验发现，部分规则子集具有良好的散列特性，并可应用于边缘检测。该算法用Java实现，适用于散列2字节RGB位图。

> **摘要翻译:** 

</details>


## <div id='cs.CL'></div> cs.CL [[Back]](#toc)

### [3] [Language Models over Canonical Byte-Pair Encodings](http://arxiv.org/pdf/2506.07956v1)
> *基于规范字节对编码的语言模型*

*['Tim Vieira', 'Tianyu Liu', 'Clemente Pasti', 'Yahya Emara', 'Brian DuSell', 'Benjamin LeBrun', 'Mario Giulianelli', 'Juan Luis Gastaldi', "Timothy J. O'Donnell", 'Ryan Cotterell']* | **Main category: {cate}**

**Keywords:** 语言模型, 字节对编码, 规范性

**Comment:** ICML 2025

> **TL;DR:** {tldr}

**AI_Comments:** 该论文提出了一个有趣的问题，并提供了两种解决方案，具有一定的创新性。

<details>
  <summary>Details</summary>

**Motivation:** 当前语言模型会给每个字符序列的指数数量级的非规范token编码赋予非零概率，这导致概率质量从合理的输出中转移出去。

**Method:** 提出了两种强制执行规范性的方法：(1) 通过条件反射实现规范性，利用测试时推理策略，无需额外训练；(2) 通过构建实现规范性，模型参数化保证规范输出，但需要训练。

**Result:** {result}

**Conclusion:** 修复规范性错误可以提高语言模型的性能。

> **ai_Abstract:** 本文提出了两种方法来强制语言模型输出的规范性，从而提高模型的性能。这两种方法分别是通过条件反射和通过构建来实现规范性。实验结果表明，修复规范性错误可以提高模型的likelihood。

> **摘要翻译:** 

</details>
