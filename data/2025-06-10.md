# ArXiv Daily Papers - 2025-06-10

## Total Papers Today: 3

<div id='toc'></div>

### Table of Contents
- [cs.LG](#cs.LG) [Total: 1]
- [nlin.CG](#nlin.CG) [Total: 1]
- [cs.CL](#cs.CL) [Total: 1]

## <div id='cs.LG'></div> cs.LG [[Back]](#toc)

### [1] [Extending AALpy with Passive Learning: A Generalized State-Merging Approach](http://arxiv.org/abs/2506.06333v1)
> *使用被动学习扩展AALpy：一种广义状态合并方法*

*['Benjamin von Berg', 'Bernhard K. Aichernig']* | **Main category: {cate}**

**Keywords:** 自动机学习, 被动学习, 状态合并, AALpy, red-blue框架

**Comment:** Accepted for publication at CAV 2025, the 37th International
  Conference on Computer Aided Verification

> **TL;DR:** AALpy库通过广义状态合并方法扩展了被动学习功能，简化了状态合并算法的实现。

**AI_Comments:** 该论文通过在AALpy库中引入通用的状态合并框架，有效扩展了其功能，并降低了被动学习算法的实现难度。这对于自动机学习领域的研究者和开发者具有一定的实用价值。

<details>
  <summary>Details</summary>

**Motivation:** 为了扩展AALpy库的功能，使其支持被动自动机学习领域中的状态合并方法。

**Method:** 在red-blue框架下，使用通用的内部表示来实现不同自动机类型的状态合并算法。

**Result:** 

**Conclusion:** 通过AALpy实现状态合并算法，可以减少实现工作量，主要集中在兼容性标准和评分的定义上，从而有助于现有和新型算法的实现。

> **ai_Abstract:** 本文介绍了AALpy库通过实现red-blue框架下的广义状态合并方法，扩展了其在被动自动机学习方面的功能。该实现采用通用内部表示，支持不同类型的自动机，并显著简化了状态合并算法的定义和执行过程。实验结果表明，使用AALpy可以大大减少状态合并算法的实现工作量。

> **摘要翻译:** AALpy是一个完善的开源自动机学习库，用Python编写，专注于具有IO行为的系统的主动学习。它为不同的自动机类型提供了广泛的最新算法，范围从完全确定性到概率自动机。在这项工作中，我们介绍了最近添加的来自被动自动机学习领域的重要方法的广义实现：red-blue框架中的状态合并。使用不同自动机类型的通用内部表示允许red-blue框架的通用和高度可配置的实现。我们描述了如何使用AALpy定义和执行状态合并算法，这减少了状态合并算法的实现工作量，主要集中在兼容性标准和评分的定义上。这有助于现有和新型算法的实现。特别是，使用AALpy从文献中定义一些现有的状态合并算法只需几行代码。

</details>


## <div id='nlin.CG'></div> nlin.CG [[Back]](#toc)

### [2] [Elementary Cellular Automata as Non-Cryptographic Hash Functions](http://arxiv.org/abs/2506.06551v1)
> *将基本细胞自动机作为非密码散列函数*

*['Daniel McKinley']* | **Main category: {cate}**

**Keywords:** 细胞自动机, 散列函数, 误差最小化, 边缘检测, 有损压缩

**Comment:** 

> **TL;DR:** 使用基本细胞自动机实现散列函数，该函数具有误差最小化、唯一解和高效追溯散列等特性。

**AI_Comments:** 该论文提出了一种新颖的散列函数实现方法，利用了基本细胞自动机的特性。该方法具有一定的创新性，但其安全性和性能还需要进一步评估。

<details>
  <summary>Details</summary>

**Motivation:** 探索基本细胞自动机作为散列函数的潜力。

**Method:** 使用误差最小化有损压缩算法在包裹的 4x4 邻域单元上实现 10 个基本细胞自动机 (ECA) 作为散列函数。

**Result:** 

**Conclusion:** 基本细胞自动机可以有效地用作非密码散列函数。

> **ai_Abstract:** 本文提出了一种使用基本细胞自动机作为非密码散列函数的方法。通过误差最小化有损压缩算法，在 4x4 邻域单元上实现了 10 个 ECA 规则。实验结果表明，这些规则具有误差最小化、唯一解和高效追溯散列等特性，可应用于边缘检测。

> **摘要翻译:** 实现了 256 个基本细胞自动机 (ECA) 中的 10 个子集，作为散列函数，使用在包裹的 4x4 邻域单元上运行的误差最小化有损压缩算法。处理所有 256 个规则，发现 8 个规则的两个子集中的 10 个规则具有误差最小化和最大化、唯一解、有损逆、高效追溯散列以及边缘检测应用等特性。该算法与快速傅里叶变换和快速 Walsh-Hadamard 变换的嵌套二次幂结构并行，用 Java 实现，旨在散列任何 2 字节 RGB 代码位图。

</details>


## <div id='cs.CL'></div> cs.CL [[Back]](#toc)

### [3] [Language Models over Canonical Byte-Pair Encodings](http://arxiv.org/abs/2506.07956v1)
> *基于规范字节对编码的语言模型*

*['Tim Vieira', 'Tianyu Liu', 'Clemente Pasti', 'Yahya Emara', 'Brian DuSell', 'Benjamin LeBrun', 'Mario Giulianelli', 'Juan Luis Gastaldi', "Timothy J. O'Donnell", 'Ryan Cotterell']* | **Main category: {cate}**

**Keywords:** 语言模型, 字节对编码, 规范性

**Comment:** ICML 2025

> **TL;DR:** 语言模型会给不可能出现的token序列赋予非零概率，这浪费了概率质量。本文提出了两种方法来强制执行规范性，提高了模型的性能。

**AI_Comments:** 本文创新性地提出了两种方法来解决语言模型中非规范token编码的问题，并通过实验验证了其有效性。该研究对于提高语言模型的效率和准确性具有重要意义。

<details>
  <summary>Details</summary>

**Motivation:** 现有的语言模型会将非零概率分配给大量不应该出现的token序列，这导致了概率质量的浪费。

**Method:** 提出了两种方法来强制执行token级别语言模型的规范性：（1）通过条件反射实现规范性，利用测试时推理策略，无需额外训练；（2）通过构建实现规范性，这是一种保证规范输出的模型参数化，但需要训练。

**Result:** 

**Conclusion:** 通过强制执行规范性，可以提高语言模型的性能，避免概率质量的浪费。

> **ai_Abstract:** 本文提出了两种方法来强制执行token级别语言模型的规范性，确保只有规范token字符串被分配正概率。这两种方法分别是：通过条件反射实现规范性，利用测试时推理策略，无需额外训练；以及通过构建实现规范性，这是一种保证规范输出的模型参数化，但需要训练。实验结果表明，修正规范性错误可以提高几个模型和语料库的held-out数据的可能性。

> **摘要翻译:** 现代语言模型将字符字符串上的概率分布表示为通过确定性分词器（如字节对编码）导出的（较短）token字符串上的分布。虽然这种方法在将语言模型扩展到大型语料库方面非常有效，但其目前的化身具有一个令人担忧的属性：该模型为每个字符字符串的指数数量的非规范token编码分配非零概率质量——这些token字符串解码为有效的字符字符串，但在确定性分词器下是不可能的（即，无论训练语料库有多大，它们都不会出现在任何训练语料库中）。这种错误分配既是错误的，因为非规范字符串永远不会出现在训练数据中，也是浪费的，将概率质量从合理的输出中转移出去。这些都是可以避免的错误！在这项工作中，我们提出了在token级别语言模型中强制执行规范性的方法，确保只有规范token字符串被分配正概率。我们提出了两种方法：（1）通过条件反射实现规范性，利用测试时推理策略，无需额外训练；（2）通过构建实现规范性，这是一种保证规范输出的模型参数化，但需要训练。我们证明，修正规范性错误可以提高几个模型和语料库的held-out数据的可能性。

</details>
