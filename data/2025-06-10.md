# ArXiv Daily Papers - 2025-06-10

## Total Papers Today: 3

<div id='toc'></div>

### Table of Contents
- [cs.LG](#cs.LG) [Total: 1]
- [nlin.CG](#nlin.CG) [Total: 1]
- [cs.CL](#cs.CL) [Total: 1]

## <div id='cs.LG'></div> cs.LG [[Back]](#toc)

### [1] [Extending AALpy with Passive Learning: A Generalized State-Merging Approach](http://arxiv.org/abs/2506.06333v1)
> *使用被动学习扩展AALpy：一种广义状态合并方法*

*['Benjamin von Berg', 'Bernhard K. Aichernig']* | **Main category: {cate}**

**Keywords:** 自动机学习, 被动学习, 状态合并, AALpy, red-blue框架

**Comment:** Accepted for publication at CAV 2025, the 37th International
  Conference on Computer Aided Verification

> **TL;DR:** AALpy通过实现通用的red-blue框架状态合并，扩展了被动学习能力，简化了状态合并算法的实现。

**AI_Comments:** 该论文通过在AALpy中引入通用的状态合并框架，显著提升了该库在被动学习方面的能力，降低了算法实现的复杂度，具有一定的创新性和实用价值。

<details>
  <summary>Details</summary>

**Motivation:** 为了扩展AALpy库的功能，使其包含被动自动机学习方法。

**Method:** 在AALpy中实现了一个通用的red-blue框架的状态合并算法，该算法使用通用的内部表示来处理不同的自动机类型。

**Result:** 

**Conclusion:** 通过在AALpy中添加通用的状态合并实现，降低了状态合并算法的实现难度，并方便了现有和新的算法的实现。

> **ai_Abstract:** 本文介绍了AALpy库的扩展，通过在red-blue框架中实现通用的状态合并方法，增加了被动学习能力。该实现利用通用的内部表示，简化了不同自动机类型的状态合并算法的定义和执行。实验结果表明，使用AALpy可以大大减少状态合并算法的实现工作量。

> **摘要翻译:** AALpy是一个完善的开源自动机学习库，使用Python编写，专注于具有IO行为的系统的主动学习。它为不同的自动机类型提供了广泛的最新算法，范围从完全确定性到概率自动机。在这项工作中，我们介绍了最近添加的来自被动自动机学习领域的重要方法的通用实现：红蓝框架中的状态合并。使用不同自动机类型的通用内部表示允许红蓝框架的通用和高度可配置的实现。我们描述了如何使用AALpy定义和执行状态合并算法，这减少了状态合并算法的实现工作，主要减少到兼容性标准和评分的定义。这有助于实现现有和新的算法。特别是，使用AALpy定义文献中的一些现有状态合并算法仅需几行代码。

</details>


## <div id='nlin.CG'></div> nlin.CG [[Back]](#toc)

### [2] [Elementary Cellular Automata as Non-Cryptographic Hash Functions](http://arxiv.org/abs/2506.06551v1)
> *初等细胞自动机作为非密码散列函数*

*['Daniel McKinley']* | **Main category: {cate}**

**Keywords:** 细胞自动机, 散列函数, 误差最小化, 边缘检测, 有损压缩

**Comment:** 

> **TL;DR:** 使用初等细胞自动机实现了一种非密码散列函数，该函数基于误差最小化有损压缩算法，并在包裹的4x4邻域单元上运行。

**AI_Comments:** 该论文提出了一种新颖的散列函数实现方法，将初等细胞自动机应用于非密码领域。该方法具有一定的创新性，但其安全性和性能还需要进一步评估。

<details>
  <summary>Details</summary>

**Motivation:** 探索初等细胞自动机在非密码散列函数中的应用。

**Method:** 实现了10个初等细胞自动机作为散列函数，使用误差最小化有损压缩算法处理包裹的4x4邻域单元。

**Result:** 

**Conclusion:** 该算法类似于快速傅里叶变换和快速沃尔什-哈达玛变换的嵌套二次幂结构，用Java实现，并构建用于散列任何2字节RGB代码位图。

> **ai_Abstract:** 本文提出了一种基于初等细胞自动机的非密码散列函数实现方法。该方法利用误差最小化有损压缩算法处理4x4邻域单元，并选择了10个具有特定属性的ECA规则。实验结果表明，该方法具有误差最小化、唯一解、高效追溯散列等特性，并可应用于边缘检测。

> **摘要翻译:** 实现了256个基本细胞自动机（ECA）的一个子集（10个），作为哈希函数，使用在包裹的4x4邻域单元上运行的误差最小化有损压缩算法。处理所有256条规则，发现8条规则的两个子集具有误差最小化和最大化、唯一解、有损逆、高效追溯哈希以及边缘检测的应用等特性。该算法类似于快速傅里叶变换和快速沃尔什-哈达玛变换的嵌套二次幂结构，用Java实现，并构建用于哈希任何2字节RGB代码位图。

</details>


## <div id='cs.CL'></div> cs.CL [[Back]](#toc)

### [3] [Language Models over Canonical Byte-Pair Encodings](http://arxiv.org/abs/2506.07956v1)
> *基于规范字节对编码的语言模型*

*['Tim Vieira', 'Tianyu Liu', 'Clemente Pasti', 'Yahya Emara', 'Brian DuSell', 'Benjamin LeBrun', 'Mario Giulianelli', 'Juan Luis Gastaldi', "Timothy J. O'Donnell", 'Ryan Cotterell']* | **Main category: {cate}**

**Keywords:** 语言模型, 字节对编码, 规范性

**Comment:** ICML 2025

> **TL;DR:** 语言模型会给不可能出现的token序列赋予非零概率，本文提出了两种方法来避免这个问题，并通过实验验证了其有效性。

**AI_Comments:** 本文针对语言模型中一个重要的实际问题提出了有效的解决方案，具有一定的创新性和实用价值。

<details>
  <summary>Details</summary>

**Motivation:** 当前语言模型会给每个字符序列的非规范token编码赋予非零概率，这既是错误的，也是浪费的，因为这些非规范字符串永远不会出现在训练数据中，从而导致概率质量从合理的输出中转移。

**Method:** 提出了两种方法来强制token级别语言模型中的规范性：(1) 通过条件反射实现规范性，利用测试时推理策略，无需额外训练；(2) 通过构建实现规范性，这是一种保证规范输出但需要训练的模型参数化。

**Result:** 

**Conclusion:** 本文提出了两种方法来解决语言模型中非规范token编码的问题，并通过实验验证了其有效性，可以提高保留数据的可能性。

> **ai_Abstract:** 本文提出了两种方法来解决语言模型中非规范token编码的问题。第一种方法是通过条件反射，利用测试时推理策略，无需额外训练。第二种方法是通过构建，需要训练模型参数化以保证规范输出。实验结果表明，修正规范性错误可以提高模型的性能。

> **摘要翻译:** 现代语言模型将字符字符串上的概率分布表示为通过确定性分词器（例如字节对编码）导出的（较短）token字符串上的分布。虽然这种方法在将语言模型扩展到大型语料库方面非常有效，但其目前的化身具有一个令人担忧的属性：该模型为每个字符字符串的指数数量的非规范token编码分配非零概率质量——这些token字符串解码为有效的字符字符串，但在确定性分词器下是不可能的（即，无论训练语料库有多大，它们永远不会出现在任何训练语料库中）。这种错误分配既是错误的，因为非规范字符串永远不会出现在训练数据中，也是浪费的，因为概率质量从合理的输出中转移。这些都是可以避免的错误！在这项工作中，我们提出了在token级别语言模型中强制执行规范性的方法，确保只有规范token字符串被分配正概率。我们提出了两种方法：（1）通过条件反射实现规范性，利用测试时推理策略，无需额外训练；（2）通过构建实现规范性，这是一种保证规范输出但需要训练的模型参数化。我们证明，修正规范性错误可以提高几个模型和语料库的保留数据的可能性。

</details>
