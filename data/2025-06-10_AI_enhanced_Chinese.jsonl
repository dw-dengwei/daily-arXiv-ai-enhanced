{"id": "2506.06333", "title": "Extending AALpy with Passive Learning: A Generalized State-Merging Approach", "authors": ["Benjamin von Berg", "Bernhard K. Aichernig"], "summary": "AALpy is a well-established open-source automata learning library written in\nPython with a focus on active learning of systems with IO behavior. It provides\na wide range of state-of-the-art algorithms for different automaton types\nranging from fully deterministic to probabilistic automata. In this work, we\npresent the recent addition of a generalized implementation of an important\nmethod from the domain of passive automata learning: state-merging in the\nred-blue framework. Using a common internal representation for different\nautomaton types allows for a general and highly configurable implementation of\nthe red-blue framework. We describe how to define and execute state-merging\nalgorithms using AALpy, which reduces the implementation effort for\nstate-merging algorithms mainly to the definition of compatibility criteria and\nscoring. This aids the implementation of both existing and novel algorithms. In\nparticular, defining some existing state-merging algorithms from the literature\nwith AALpy only takes a few lines of code.", "comment": "Accepted for publication at CAV 2025, the 37th International\n  Conference on Computer Aided Verification", "cate": "cs.LG", "url": "http://arxiv.org/pdf/2506.06333v1", "AI": {"title_translation": "AALpy的被动学习扩展：一种广义的状态合并方法", "tldr": "本文介绍了AALpy库中新增的广义状态合并实现，该实现基于红蓝框架，旨在简化被动自动机学习中状态合并算法的定义和执行，显著减少了实现工作量。", "motivation": "现有AALpy库主要专注于主动学习，为了扩展其功能并简化被动自动机学习中状态合并算法的实现，本文引入了广义状态合并方法。", "method": "通过在AALpy中引入基于红蓝框架的广义状态合并实现，利用不同自动机类型的通用内部表示，实现了高度可配置的状态合并算法。这主要通过定义兼容性标准和评分来减少实现工作量。", "result": "新的实现大大简化了状态合并算法的定义和执行，将实现工作量主要限制在兼容性标准和评分的定义上。例如，文献中一些现有算法只需几行代码即可在AALpy中实现。", "conclusion": "通过在AALpy中集成广义状态合并功能，该工作显著降低了开发和实现被动自动机学习算法的难度，为研究人员和开发者提供了更高效的工具。", "translation": "AALpy是一个成熟的开源自动机学习库，用Python编写，专注于具有IO行为的系统的主动学习。它提供了从完全确定性到概率自动机的各种最先进的算法。在这项工作中，我们介绍了最近新增的一种广义实现，它是被动自动机学习领域中一种重要方法：红蓝框架中的状态合并。使用不同自动机类型的通用内部表示，可以实现红蓝框架的通用且高度可配置的实现。我们描述了如何使用AALpy定义和执行状态合并算法，这主要将状态合并算法的实现工作量减少到兼容性标准和评分的定义。这有助于现有和新型算法的实现。特别是，使用AALpy定义文献中一些现有状态合并算法只需几行代码。", "summary": "本文介绍了对AALpy（一个专注于IO行为系统主动学习的开源自动机学习库）的最新扩展。该扩展引入了被动自动机学习领域中一种重要方法——红蓝框架下的广义状态合并实现。通过利用不同自动机类型的通用内部表示，该实现具有高度通用性和可配置性。文章描述了如何使用AALpy定义和执行状态合并算法，从而将实现工作量主要减少到兼容性标准和评分的定义，极大地简化了现有和新型算法的实现，例如，文献中的一些算法只需少量代码即可实现。", "keywords": "AALpy, 被动学习, 状态合并, 自动机学习, 红蓝框架", "comments": "这项工作通过将广义状态合并方法集成到成熟的AALpy库中，显著提升了其在被动自动机学习领域的能力。其创新之处在于提供了一个高度通用和可配置的框架，极大地简化了新旧状态合并算法的实现复杂性，从而加速了该领域的研究和开发。这对于自动机学习社区来说是一个重要的贡献。"}}
{"id": "2506.06551", "title": "Elementary Cellular Automata as Non-Cryptographic Hash Functions", "authors": ["Daniel McKinley"], "summary": "A subset of 10 of the 256 elementary cellular automata (ECA) are implemented\nas a hash function using an error minimization lossy compression algorithm\noperating on wrapped 4x4 neighborhood cells. All 256 rules are processed and 10\nrules in two subsets of 8 are found to have properties that include both error\nminimization and maximization, unique solutions, a lossy inverse, efficient\nretroactive hashing, and an application to edge detection. The algorithm\nparallels the nested powers-of-two structure of the Fast Fourier Transform and\nFast Walsh-Hadamard Transform, is implemented in Java, and is built to hash any\n2 byte RGB code bitmap.", "comment": null, "cate": "nlin.CG", "url": "http://arxiv.org/pdf/2506.06551v1", "AI": {"title_translation": "初等元胞自动机作为非加密哈希函数", "tldr": "本文研究了10个初等元胞自动机（ECA）作为非加密哈希函数，发现它们具有误差最小化/最大化、唯一解、有损逆、高效追溯哈希及边缘检测等特性。", "motivation": "探索初等元胞自动机（ECA）作为非加密哈希函数的潜力及其相关特性。", "method": "实现了256个初等元胞自动机（ECA）中的10个子集作为哈希函数，采用误差最小化有损压缩算法处理环绕的4x4邻域单元。处理了所有256条规则，算法结构类似于快速傅里叶变换和快速沃尔什-哈达玛变换，并使用Java实现，旨在哈希任何2字节RGB位图。", "result": "在处理所有256条规则后，发现10条规则（分为两个8条规则的子集）具有误差最小化和最大化、唯一解、有损逆、高效追溯哈希等特性，并可应用于边缘检测。", "conclusion": "初等元胞自动机在作为非加密哈希函数方面表现出多种有趣且有用的特性，包括误差处理、逆操作能力以及在图像处理（如边缘检测）中的潜在应用。", "translation": "256个初等元胞自动机（ECA）中的10个子集被实现为哈希函数，采用一种在环绕的4x4邻域单元上运行的误差最小化有损压缩算法。处理了所有256条规则，发现其中10条规则（分为两个8条规则的子集）具有包括误差最小化和最大化、唯一解、有损逆、高效追溯哈希等特性，并可应用于边缘检测。该算法与快速傅里叶变换和快速沃尔什-哈达玛变换的嵌套2次幂结构并行，使用Java实现，并旨在哈希任何2字节RGB代码位图。", "summary": "本文探索了将部分初等元胞自动机（ECA）用作非加密哈希函数。研究人员实现了256个ECA中的10个子集，并采用了一种基于误差最小化有损压缩的算法。通过处理所有256条规则，他们发现10条规则展现出误差最小化/最大化、唯一解、有损逆、高效追溯哈希等特性，并可应用于边缘检测。该算法在结构上类似于快速傅里叶变换和快速沃尔什-哈达玛变换，并以Java实现，用于处理2字节RGB位图。", "keywords": "初等元胞自动机, 非加密哈希函数, 误差最小化, 边缘检测, 有损压缩", "comments": "这项研究通过将初等元胞自动机应用于非加密哈希函数领域，展现了其在数据处理和图像分析中的潜力。特别是发现ECA规则具有误差最小化/最大化、有损逆和高效追溯哈希等特性，为未来在特定应用场景（如边缘检测）中利用ECA提供了新的思路。其算法结构与FFT/FWHT的并行性也暗示了潜在的计算效率。"}}
{"id": "2506.07956", "title": "Language Models over Canonical Byte-Pair Encodings", "authors": ["Tim Vieira", "Tianyu Liu", "Clemente Pasti", "Yahya Emara", "Brian DuSell", "Benjamin LeBrun", "Mario Giulianelli", "Juan Luis Gastaldi", "Timothy J. O'Donnell", "Ryan Cotterell"], "summary": "Modern language models represent probability distributions over character\nstrings as distributions over (shorter) token strings derived via a\ndeterministic tokenizer, such as byte-pair encoding. While this approach is\nhighly effective at scaling up language models to large corpora, its current\nincarnations have a concerning property: the model assigns nonzero probability\nmass to an exponential number of $\\it{noncanonical}$ token encodings of each\ncharacter string -- these are token strings that decode to valid character\nstrings but are impossible under the deterministic tokenizer (i.e., they will\nnever be seen in any training corpus, no matter how large). This misallocation\nis both erroneous, as noncanonical strings never appear in training data, and\nwasteful, diverting probability mass away from plausible outputs. These are\navoidable mistakes! In this work, we propose methods to enforce canonicality in\ntoken-level language models, ensuring that only canonical token strings are\nassigned positive probability. We present two approaches: (1) canonicality by\nconditioning, leveraging test-time inference strategies without additional\ntraining, and (2) canonicality by construction, a model parameterization that\nguarantees canonical outputs but requires training. We demonstrate that fixing\ncanonicality mistakes improves the likelihood of held-out data for several\nmodels and corpora.", "comment": "ICML 2025", "cate": "cs.CL", "url": "http://arxiv.org/pdf/2506.07956v1", "AI": {"title_translation": "基于规范字节对编码的语言模型", "tldr": "现代语言模型在处理字节对编码时，会错误地为非规范的token编码分配概率，这既是错误的也造成了浪费。本文提出了两种方法（条件化和构建）来强制执行规范性，从而提高了模型在未见数据上的似然性。", "motivation": "现代语言模型使用确定性分词器（如字节对编码）将字符字符串表示为token字符串的概率分布。然而，这些模型会为每个字符字符串的指数级数量的“非规范”token编码分配非零概率质量，这些编码虽然可以解码为有效字符字符串，但不可能通过确定性分词器生成，因此永远不会出现在训练数据中。这种错误分配既是错误的（因为非规范字符串从未出现在训练数据中），也是浪费的（将概率质量从合理输出中转移）。", "method": "本文提出了两种强制执行token级别语言模型规范性的方法，以确保只有规范的token字符串被赋予正概率：1. 通过条件化实现规范性：利用测试时推理策略，无需额外训练。2. 通过构建实现规范性：一种模型参数化方法，保证规范输出但需要训练。", "result": "实验证明，纠正规范性错误可以提高多个模型和语料库在未见数据上的似然性。", "conclusion": "通过强制语言模型仅为规范的token编码分配概率，可以纠正现有模型中的错误和浪费，从而提高模型的性能和效率。", "translation": "现代语言模型将字符字符串的概率分布表示为通过确定性分词器（如字节对编码）派生出的（更短的）token字符串的分布。尽管这种方法在将语言模型扩展到大型语料库方面非常有效，但其目前的实现方式存在一个令人担忧的特性：模型为每个字符字符串的指数级数量的“非规范”token编码分配非零概率质量——这些token字符串可以解码为有效的字符字符串，但根据确定性分词器是不可能的（即，无论语料库多大，它们都不会出现在任何训练语料库中）。这种错误分配既是错误的，因为非规范字符串从未出现在训练数据中，也是浪费的，因为它将概率质量从合理输出中转移。这些都是可避免的错误！在这项工作中，我们提出了在token级别语言模型中强制执行规范性的方法，确保只有规范的token字符串被赋予正概率。我们提出了两种方法：（1）通过条件化实现规范性，利用测试时推理策略而无需额外训练，以及（2）通过构建实现规范性，这是一种保证规范输出但需要训练的模型参数化。我们证明，纠正规范性错误可以提高多个模型和语料库在未见数据上的似然性。", "summary": "现代语言模型在处理字符字符串时，通过确定性分词器（如字节对编码）将其转换为token字符串。然而，现有方法存在一个问题：模型会为大量不可能通过分词器生成的“非规范”token编码分配非零概率，这既是错误的，也造成了概率质量的浪费。为了解决这个问题，本文提出了两种方法来强制语言模型只为规范的token字符串分配正概率：一种是通过测试时的推理策略（无需额外训练）实现的“条件化”，另一种是通过模型参数化（需要训练）实现的“构建”。实验结果表明，纠正这些规范性错误能够提高模型在未见数据上的似然性。", "keywords": "语言模型, 字节对编码, 规范性, token化, 概率分配", "comments": "这项工作识别并解决了现代语言模型在处理字节对编码时一个关键但常被忽视的问题：非规范token编码的概率分配。通过提出两种不同的解决方案（无需训练的测试时策略和需要训练的模型重参数化），该研究不仅提供了实用的改进方法，而且深入探讨了语言模型内部表示的规范性问题，对于提高模型效率和准确性具有重要意义。"}}
