{"id": "2509.18337", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.18337", "abs": "https://arxiv.org/abs/2509.18337", "authors": ["Bo Xiong", "Linghao Zhang", "Chong Wang", "Peng Liang"], "title": "CoRaCMG: Contextual Retrieval-Augmented Framework for Commit Message Generation", "comment": "15 pages, 4 images, 6 tables, Manuscript submitted to a Journal\n  (2025)", "summary": "Commit messages play a key role in documenting the intent behind code\nchanges. However, they are often low-quality, vague, or incomplete, limiting\ntheir usefulness. Commit Message Generation (CMG) aims to automatically\ngenerate descriptive commit messages from code diffs to reduce developers'\neffort and improve message quality. Although recent advances in LLMs have shown\npromise in automating CMG, their performance remains limited. This paper aims\nto enhance CMG performance by retrieving similar diff-message pairs to guide\nLLMs to generate commit messages that are more precise and informative. We\nproposed CoRaCMG, a Contextual Retrieval-augmented framework for Commit Message\nGeneration, structured in three phases: (1) Retrieve: retrieving the similar\ndiff-message pairs; (2) Augment: combining them with the query diff into a\nstructured prompt; and (3) Generate: generating commit messages corresponding\nto the query diff via LLMs. CoRaCMG enables LLMs to learn project-specific\nterminologies and writing styles from the retrieved diff-message pairs, thereby\nproducing high-quality commit messages. We evaluated our method on various\nLLMs, including closed-source GPT models and open-source DeepSeek models.\nExperimental results show that CoRaCMG significantly boosts LLM performance\nacross four metrics (BLEU, Rouge-L, METEOR, and CIDEr). Specifically,\nDeepSeek-R1 achieves relative improvements of 76% in BLEU and 71% in CIDEr when\naugmented with a single retrieved example pair. After incorporating the single\nexample pair, GPT-4o achieves the highest improvement rate, with BLEU\nincreasing by 89%. Moreover, performance gains plateau after more than three\nexamples are used, indicating diminishing returns. Further analysis shows that\nthe improvements are attributed to the model's ability to capture the\nterminologies and writing styles of human-written commit messages from the\nretrieved example pairs."}
{"id": "2509.18361", "categories": ["cs.SE", "cs.AI", "cs.HC"], "pdf": "https://arxiv.org/pdf/2509.18361", "abs": "https://arxiv.org/abs/2509.18361", "authors": ["Daye Nam", "Malgorzata Salawa", "Satish Chandra"], "title": "Reading Between the Lines: Scalable User Feedback via Implicit Sentiment in Developer Prompts", "comment": null, "summary": "Evaluating developer satisfaction with conversational AI assistants at scale\nis critical but challenging. User studies provide rich insights, but are\nunscalable, while large-scale quantitative signals from logs or in-product\nratings are often too shallow or sparse to be reliable. To address this gap, we\npropose and evaluate a new approach: using sentiment analysis of developer\nprompts to identify implicit signals of user satisfaction. With an analysis of\nindustrial usage logs of 372 professional developers, we show that this\napproach can identify a signal in ~8% of all interactions, a rate more than 13\ntimes higher than explicit user feedback, with reasonable accuracy even with an\noff-the-shelf sentiment analysis approach. This new practical approach to\ncomplement existing feedback channels would open up new directions for building\na more comprehensive understanding of the developer experience at scale."}
{"id": "2509.18454", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.18454", "abs": "https://arxiv.org/abs/2509.18454", "authors": ["Andrzej Białecki", "Piotr Białecki", "Piotr Sowiński", "Mateusz Budziak", "Jan Gajewski"], "title": "SC2Tools: StarCraft II Toolset and Dataset API", "comment": null, "summary": "Computer games, as fully controlled simulated environments, have been\nutilized in significant scientific studies demonstrating the application of\nReinforcement Learning (RL). Gaming and esports are key areas influenced by the\napplication of Artificial Intelligence (AI) and Machine Learning (ML) solutions\nat scale. Tooling simplifies scientific workloads and is essential for\ndeveloping the gaming and esports research area.\n  In this work, we present ``SC2Tools'', a toolset containing multiple\nsubmodules responsible for working with, and producing larger datasets. We\nprovide a modular structure of the implemented tooling, leaving room for future\nextensions where needed. Additionally, some of the tools are not StarCraft~2\nexclusive and can be used with other types of data for dataset creation.\n  The tools we present were leveraged in creating one of the largest\nStarCraft~2 tournament datasets to date with a separate PyTorch and PyTorch\nLightning application programming interface (API) for easy access to the data.\n  We conclude that alleviating the burden of data collection, preprocessing,\nand custom code development is essential for less technically proficient\nresearchers to engage in the growing gaming and esports research area. Finally,\nour solution provides some foundational work toward normalizing experiment\nworkflow in StarCraft~2"}
{"id": "2509.18548", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.18548", "abs": "https://arxiv.org/abs/2509.18548", "authors": ["Steven R Brandt", "Max Morris", "Patrick Diehl", "Christopher Bowen", "Jacob Tucker", "Lauren Bristol", "Golden G. Richard III"], "title": "Locking Down Science Gateways", "comment": null, "summary": "The most recent Linux kernels have a new feature for securing applications:\nLandlock. Like Seccomp before it, Landlock makes it possible for a running\nprocess to give up access to resources. For applications running as Science\nGateways, network access is required while starting up MPI, but for the sake of\nsecurity, it should be taken away prior to the reading of user-supplied\nparameter files. We explore the usefulness of Landlock by modifying and locking\ndown three mature scientific codes: The Einstein Toolkit (a code that studies\nthe dynamics of relativistic astrophysics, e.g. neutron star collisions),\nOcto-Tiger (a code for studying the dynamics of non-relativistic astrophysics,\ne.g. white dwarfs), and FUKA (an initial data solver for relativistic codes).\nFinally, we implement a fully-functioning FUKA science gateway that relies on\nLandlock (instead of user authentication) for security."}
{"id": "2509.18684", "categories": ["cs.PF"], "pdf": "https://arxiv.org/pdf/2509.18684", "abs": "https://arxiv.org/abs/2509.18684", "authors": ["Abdur Razzak", "Atanu Barai", "Nandakishore Santhi", "Abdel-Hameed A. Badawy"], "title": "Static Estimation of Reuse Profiles for Arrays in Nested Loops", "comment": "This paper is accepted at the MEMSYS 2025 conference, 11th\n  International Symposium on Memory Systems, Washington D.C., October 7 -\n  October 8, 2025", "summary": "Efficient memory access patterns play a crucial role in determining the\noverall performance of applications by exploiting temporal and spatial\nlocality, thus maximizing cache locality. The Reuse Distance Histogram (RDH) is\na widely used metric to quantify temporal locality, measuring the distance\nbetween consecutive accesses to the same memory location. Traditionally,\ncalculating RDH requires program execution and memory trace collection to\nobtain dynamic memory access behavior. This trace collection is often\ntime-consuming, resource-intensive, and unsuitable for early-stage optimization\nor large-scale applications. Static prediction, on the other hand, offers a\nsignificant speedup in estimating RDH and cache hit rates. However, these\napproaches lack accuracy, since the predictions come without running the\nprogram and knowing the complete memory access pattern, more specifically when\narrays are used inside nested loops. This paper presents a novel static\nanalysis framework for predicting the reuse profiles of array references in\nprograms with nested loop structures, without requiring any runtime\ninformation. By analyzing loop bounds, access patterns in smaller problem\nsizes, and predictive equations, our method predicts access patterns of arrays\nand estimates reuse distances and cache hit rate at compile time. This paper\nextends our previous study by incorporating more analysis and improving\nprediction by addressing previously unhandled reuse patterns. We evaluate our\ntechnique against a widely accepted traditional trace-driven profiling tool,\nParallel Reuse Distance Analysis (PARDA). The results demonstrate that our\nstatic predictor achieves comparable accuracy while offering\norders-of-magnitude improvement in the analysis speed. This work offers a\npractical alternative to dynamic reuse profiling and paves the way for\nintegration into compilers and static performance modeling tools."}
{"id": "2509.18472", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2509.18472", "abs": "https://arxiv.org/abs/2509.18472", "authors": ["Atanu Barai", "Kamalavasan Kamalakkannan", "Patrick Diehl", "Maxim Moraru", "Jered Dominguez-Trujillo", "Howard Pritchard", "Nandakishore Santhi", "Farzad Fatollahi-Fard", "Galen Shipman"], "title": "Bridging Simulation and Silicon: A Study of RISC-V Hardware and FireSim Simulation", "comment": null, "summary": "RISC-V ISA-based processors have recently emerged as both powerful and\nenergy-efficient computing platforms. The release of the MILK-V Pioneer marked\na significant milestone as the first desktop-grade RISC-V system. With\nincreasing engagement from both academia and industry, such platforms exhibit\nstrong potential for adoption in high-performance computing (HPC) environments.\n  The open-source, FPGA-accelerated FireSim framework has emerged as a flexible\nand scalable tool for architectural exploration, enabling simulation of various\nsystem configurations using RISC-V cores. Despite its capabilities, there\nremains a lack of systematic evaluation regarding the feasibility and\nperformance prediction accuracy of FireSim when compared to physical hardware.\n  In this study, we address this gap by modeling a commercially available\nsingle-board computer and a desktop-grade RISC-V CPU within FireSim. To ensure\nfidelity between simulation and real hardware, we first measure the performance\nof a series of benchmarks to compare runtime behavior under single-core and\nfour-core configurations. Based on the closest matching simulation parameters,\nwe subsequently evaluate performance using a representative mini-application\nand the LAMMPS molecular dynamics code.\n  Our findings indicate that while FireSim provides valuable insights into\narchitectural performance trends, discrepancies remain between simulated and\nmeasured runtimes. These deviations stem from both inherent limitations of the\nsimulation environment and the restricted availability of detailed performance\nspecifications from CPU manufacturers, which hinder precise configuration\nmatching."}
{"id": "2509.18808", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.18808", "abs": "https://arxiv.org/abs/2509.18808", "authors": ["Zexun Zhan", "Shuzheng Gao", "Ruida Hu", "Cuiyun Gao"], "title": "SR-Eval: Evaluating LLMs on Code Generation under Stepwise Requirement Refinement", "comment": null, "summary": "Large language models (LLMs) have achieved remarkable progress in code\ngeneration. However, existing benchmarks mainly formalize the task as a static,\nsingle-turn problem, overlooking the stepwise requirement changes and iterative\nworkflows in real-world software development. This mismatch limits the\nunderstanding of how well LLMs can support real-world development workflows.\nConstructing such iterative benchmarks is challenging due to the lack of public\ninteraction traces and the difficulty of creating discriminative, turn-specific\ntest cases.\n  To bridge this gap, we present SR-Eval, a benchmark specifically designed to\nassess LLMs on iterative code generation under Stepwise requirements\nRefinement. SR-Eval spans both function-level and repository-level tasks in\nPython and Java, enabling fine-grained and progressive evaluation across\nevolving requirements. The construction of SR-Eval follows a carefully designed\npipeline that first leverages a multi-agent-based requirement generation method\nto simulate the development process and recover the multi-round interaction\nprocess from final requirements, then employs a semantic-aware discriminative\ntest case generation component to ensure discriminative and consistent\nevaluation at each turn. SR-Eval comprises 443 multi-turn tasks and 1,857\nquestions at both function and repository levels. Using SR-Eval, we evaluate 11\nrepresentative LLMs with three prompting strategies that simulate different\nusage patterns. Results show that iterative code generation under stepwise\nrequirement refinement remains highly challenging: the best-performing model\nachieves only 22.67% completion rate on function-level tasks and 20.00% on\nrepository-level tasks. We further observe that prompting strategies\nsubstantially influence performance, highlighting the need for the development\nof advanced methods."}
{"id": "2509.18886", "categories": ["cs.PF", "cs.AR", "cs.CR", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.18886", "abs": "https://arxiv.org/abs/2509.18886", "authors": ["Marcin Chrapek", "Marcin Copik", "Etienne Mettaz", "Torsten Hoefler"], "title": "Confidential LLM Inference: Performance and Cost Across CPU and GPU TEEs", "comment": null, "summary": "Large Language Models (LLMs) are increasingly deployed on converged Cloud and\nHigh-Performance Computing (HPC) infrastructure. However, as LLMs handle\nconfidential inputs and are fine-tuned on costly, proprietary datasets, their\nheightened security requirements slow adoption in privacy-sensitive sectors\nsuch as healthcare and finance. We investigate methods to address this gap and\npropose Trusted Execution Environments (TEEs) as a solution for securing\nend-to-end LLM inference. We validate their practicality by evaluating these\ncompute-intensive workloads entirely within CPU and GPU TEEs. On the CPU side,\nwe conduct an in-depth study running full Llama2 inference pipelines (7B, 13B,\n70B) inside Intel's TDX and SGX, accelerated by Advanced Matrix Extensions\n(AMX). We derive 12 insights, including that across various data types, batch\nsizes, and input lengths, CPU TEEs impose under 10% throughput and 20% latency\noverheads, further reduced by AMX. We run LLM inference on NVIDIA H100\nConfidential Compute GPUs, contextualizing our CPU findings and observing\nthroughput penalties of 4-8% that diminish as batch and input sizes grow. By\ncomparing performance, cost, and security trade-offs, we show how CPU TEEs can\nbe more cost-effective or secure than their GPU counterparts. To our knowledge,\nour work is the first to comprehensively demonstrate the performance and\npracticality of modern TEEs across both CPUs and GPUs for enabling confidential\nLLMs (cLLMs)."}
{"id": "2509.18735", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2509.18735", "abs": "https://arxiv.org/abs/2509.18735", "authors": ["Muhammad Ahmed Mohsin", "Muhammad Umer", "Ahsan Bilal", "Muhammad Ali Jamshed", "Dean F. Hougen", "John M. Cioffi"], "title": "6G Twin: Hybrid Gaussian Radio Fields for Channel Estimation and Non-Linear Precoder Design for Radio Access Networks", "comment": "Submitted to IEEE Transactions on Wireless Communications", "summary": "This work introduces 6G Twin, the first end-to-end artificial intelligence\n(AI)-native radio access network (RAN) design that unifies (i) neural Gaussian\nRadio Fields (GRF) for compressed channel state information (CSI) acquisition,\n(ii) continual channel prediction with handover persistence, and (iii) an\nenergy-optimal nonlinear precoder (minPMAC). GRF replaces dense pilots with a\nsparse Gaussian field, cutting pilot overhead by about 100x while delivering\n1.1 ms inference and less than 2 minutes on-site training, thus enabling\nmillisecond-scale closed-loop operation. A replay-driven continual learner\nsustains accuracy under mobility and cell transitions, improving channel\nnormalized mean square error (NMSE) by more than 10 dB over frozen predictors\nand an additional 2-5 dB over uniform replay, thereby stabilizing performance\nacross UMi/UMa handovers. Finally, minPMAC solves a convex, order-free MAC\nprecoder design that recovers the globally optimal order from Broadcast Channel\n(BC) duals and minimizes transmit energy subject to minimum-rate guarantees,\nachieving 4-10 times lower energy (scenario dependent) with monotonically\nincreasing bits per joule as SNR grows. This translates to up to 5 times higher\ndata rate at comparable power or the same rates at substantially lower power.\nTogether, these components form a practical, GPU-ready framework that attains\nreal-time CSI, robust tracking in dynamic networks with efficient handovers,\nand state-of-the-art throughput-energy tradeoffs under 3GPP-style settings."}
{"id": "2509.19136", "categories": ["cs.SE", "cs.AI", "D.2.4; D.2.5; F.3.1"], "pdf": "https://arxiv.org/pdf/2509.19136", "abs": "https://arxiv.org/abs/2509.19136", "authors": ["Sébastien Salva", "Redha Taguelmimt"], "title": "On the Soundness and Consistency of LLM Agents for Executing Test Cases Written in Natural Language", "comment": null, "summary": "The use of natural language (NL) test cases for validating graphical user\ninterface (GUI) applications is emerging as a promising direction to manually\nwritten executable test scripts, which are costly to develop and difficult to\nmaintain. Recent advances in large language models (LLMs) have opened the\npossibility of the direct execution of NL test cases by LLM agents. This paper\ninvestigates this direction, focusing on the impact on NL test case unsoundness\nand on test case execution consistency. NL test cases are inherently unsound,\nas they may yield false failures due to ambiguous instructions or unpredictable\nagent behaviour. Furthermore, repeated executions of the same NL test case may\nlead to inconsistent outcomes, undermining test reliability. To address these\nchallenges, we propose an algorithm for executing NL test cases with guardrail\nmechanisms and specialised agents that dynamically verify the correct execution\nof each test step. We introduce measures to evaluate the capabilities of LLMs\nin test execution and one measure to quantify execution consistency. We propose\na definition of weak unsoundness to characterise contexts in which NL test case\nexecution remains acceptable, with respect to the industrial quality levels Six\nSigma. Our experimental evaluation with eight publicly available LLMs, ranging\nfrom 3B to 70B parameters, demonstrates both the potential and current\nlimitations of current LLM agents for GUI testing. Our experiments show that\nMeta Llama 3.1 70B demonstrates acceptable capabilities in NL test case\nexecution with high execution consistency (above the level 3-sigma). We provide\nprototype tools, test suites, and results."}
{"id": "2509.19027", "categories": ["cs.PF", "cs.AR", "68M20, 60J10", "C.1.1; C.4"], "pdf": "https://arxiv.org/pdf/2509.19027", "abs": "https://arxiv.org/abs/2509.19027", "authors": ["Faruk Alpay", "Hamdi Alakkad"], "title": "Glass-Box Analysis for Computer Systems: Transparency Index, Shapley Attribution, and Markov Models of Branch Prediction", "comment": "20 pages, 2 figures, 3 tables, 1 pseudocode", "summary": "We formalize glass-box analysis for computer systems and introduce three\nprincipled tools. First, the Glass-Box Transparency Index (GTI) quantifies the\nfraction of performance variance explainable by internal features and comes\nequipped with bounds, invariances, cross-validated estimation, and bootstrap\nconfidence intervals. Second, Explainable Throughput Decomposition (ETD) uses\nShapley values to provide an efficiency-preserving attribution of throughput,\ntogether with non-asymptotic Monte Carlo error guarantees and convexity\n(Jensen) gap bounds. Third, we develop an exact Markov analytic framework for\nbranch predictors, including a closed-form misprediction rate for a two-bit\nsaturating counter under a two-state Markov branch process and its i.i.d.\ncorollary. Additionally, we establish an identifiability theorem for recovering\nevent rates from aggregated hardware counters and provide stability bounds\nunder noise."}
{"id": "2509.18869", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2509.18869", "abs": "https://arxiv.org/abs/2509.18869", "authors": ["Baiqiang Wang", "Dongfang Zhao", "Nathan R Tallent", "Luanzheng Guo"], "title": "On The Reproducibility Limitations of RAG Systems", "comment": null, "summary": "Retrieval-Augmented Generation (RAG) is increasingly employed in generative\nAI-driven scientific workflows to integrate rapidly evolving scientific\nknowledge bases, yet its reliability is frequently compromised by\nnon-determinism in their retrieval components. This paper introduces ReproRAG,\na comprehensive benchmarking framework designed to systematically measure and\nquantify the reproducibility of vector-based retrieval systems. ReproRAG\ninvestigates sources of uncertainty across the entire pipeline, including\ndifferent embedding models, precision, retrieval algorithms, hardware\nconfigurations, and distributed execution environments. Utilizing a suite of\nmetrics, such as Exact Match Rate, Jaccard Similarity, and Kendall's Tau, the\nproposed framework effectively characterizes the trade-offs between\nreproducibility and performance. Our large-scale empirical study reveals\ncritical insights; for instance, we observe that different embedding models\nhave remarkable impact on RAG reproducibility. The open-sourced ReproRAG\nframework provides researchers and engineers productive tools to validate\ndeployments, benchmark reproducibility, and make informed design decisions,\nthereby fostering more trustworthy AI for science."}
{"id": "2509.19185", "categories": ["cs.SE", "cs.ET"], "pdf": "https://arxiv.org/pdf/2509.19185", "abs": "https://arxiv.org/abs/2509.19185", "authors": ["Mohammed Mehedi Hasan", "Hao Li", "Emad Fallahzadeh", "Gopi Krishnan Rajbahadur", "Bram Adams", "Ahmed E. Hassan"], "title": "An Empirical Study of Testing Practices in Open Source AI Agent Frameworks and Agentic Applications", "comment": null, "summary": "Foundation model (FM)-based AI agents are rapidly gaining adoption across\ndiverse domains, but their inherent non-determinism and non-reproducibility\npose testing and quality assurance challenges. While recent benchmarks provide\ntask-level evaluations, there is limited understanding of how developers verify\nthe internal correctness of these agents during development.\n  To address this gap, we conduct the first large-scale empirical study of\ntesting practices in the AI agent ecosystem, analyzing 39 open-source agent\nframeworks and 439 agentic applications. We identify ten distinct testing\npatterns and find that novel, agent-specific methods like DeepEval are seldom\nused (around 1%), while traditional patterns like negative and membership\ntesting are widely adapted to manage FM uncertainty. By mapping these patterns\nto canonical architectural components of agent frameworks and agentic\napplications, we uncover a fundamental inversion of testing effort:\ndeterministic components like Resource Artifacts (tools) and Coordination\nArtifacts (workflows) consume over 70% of testing effort, while the FM-based\nPlan Body receives less than 5%. Crucially, this reveals a critical blind spot,\nas the Trigger component (prompts) remains neglected, appearing in around 1% of\nall tests.\n  Our findings offer the first empirical testing baseline in FM-based agent\nframeworks and agentic applications, revealing a rational but incomplete\nadaptation to non-determinism. To address it, framework developers should\nimprove support for novel testing methods, application developers must adopt\nprompt regression testing, and researchers should explore barriers to adoption.\nStrengthening these practices is vital for building more robust and dependable\nAI agents."}
{"id": "2509.18957", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2509.18957", "abs": "https://arxiv.org/abs/2509.18957", "authors": ["Shengye Song", "Minxian Xu", "Kan Hu", "Wenxia Guo", "Kejiang Ye"], "title": "TD3-Sched: Learning to Orchestrate Container-based Cloud-Edge Resources via Distributed Reinforcement Learning", "comment": "14 pages, 5 figures", "summary": "Resource scheduling in cloud-edge systems is challenging as edge nodes run\nlatency-sensitive workloads under tight resource constraints, while existing\ncentralized schedulers can suffer from performance bottlenecks and user\nexperience degradation. To address the issues of distributed decisions in\ncloud-edge environments, we present TD3-Sched, a distributed reinforcement\nlearning (DRL) scheduler based on Twin Delayed Deep Deterministic Policy\nGradient (TD3) for continuous control of CPU and memory allocation, which can\nachieve optimized decisions for resource provisioning under dynamic workloads.\nOn a realistic cloud-edge testbed with SockShop application and Alibaba traces,\nTD3-Sched achieves reductions of 17.9% to 38.6% in latency under same loads\ncompared with other reinforcement-learning and rule-based baselines, and 16% to\n31.6% under high loads. TD3-Sched also shows superior Service Level Objective\n(SLO) compliance with only 0.47% violations. These results indicate faster\nconvergence, lower latency, and more stable performance while preserving\nservice quality in container-based cloud-edge environment compared with the\nbaselines."}
{"id": "2509.19086", "categories": ["cs.DC", "D.4.1; C.4; C.1.4; D.1.3"], "pdf": "https://arxiv.org/pdf/2509.19086", "abs": "https://arxiv.org/abs/2509.19086", "authors": ["Michal Konopa", "Jan Fesl", "Ladislav Beránek"], "title": "Scheduler-Driven Job Atomization", "comment": "22 pages", "summary": "Modern GPU clusters, particularly those built on NVIDIA's Multi-Instance GPU\n(MIG) architecture, often suffer from inefficiencies because jobs are treated\nas rigid, indivisible blocks that occupy a fixed slice until completion. The\nreliance on static peak memory estimates exacerbates fragmentation,\nunderutilization, and job rejections. We propose Scheduler-Driven Job\nAtomization (SJA), a new paradigm that establishes a bidirectional interaction\nbetween scheduler and jobs. In SJA, the scheduler advertises available\nexecution gaps, and jobs respond by signaling interest if they can potentially\ngenerate a subjob that fits the offered time-capacity window. The scheduler may\ncollect multiple signals for the same slot and, based on its allocation policy\n(e.g., fairness, efficiency, or SLA priorities), selects which job is granted\nthe slot. Only then does the chosen job materialize a safe, self-contained\nsubjob tailored to that opportunity. Unlike migration or preemption, SJA\nproactively shapes workloads before execution, thereby avoiding costly state\ntransfers and unpredictable interruptions. It aims to increase GPU utilization,\nreduce wait times, and minimize migration overhead by aligning jobs with\nopportunities in real time, ensuring that each admitted subjob is correct by\nconstruction. This paper is presented as a concept paper: it introduces the\nparadigm, defines its building blocks, and outlines future research directions,\nrather than offering a full experimental evaluation."}
{"id": "2509.19150", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2509.19150", "abs": "https://arxiv.org/abs/2509.19150", "authors": ["Harikrishna Tummalapalli", "Riccardo Balin", "Christine M. Simpson", "Andrew Park", "Aymen Alsaadi", "Andrew E. Shao", "Wesley Brewer", "Shantenu Jha"], "title": "In-Transit Data Transport Strategies for Coupled AI-Simulation Workflow Patterns", "comment": null, "summary": "Coupled AI-Simulation workflows are becoming the major workloads for HPC\nfacilities, and their increasing complexity necessitates new tools for\nperformance analysis and prototyping of new in-situ workflows. We present\nSimAI-Bench, a tool designed to both prototype and evaluate these coupled\nworkflows. In this paper, we use SimAI-Bench to benchmark the data transport\nperformance of two common patterns on the Aurora supercomputer: a one-to-one\nworkflow with co-located simulation and AI training instances, and a\nmany-to-one workflow where a single AI model is trained from an ensemble of\nsimulations. For the one-to-one pattern, our analysis shows that node-local and\nDragonHPC data staging strategies provide excellent performance compared Redis\nand Lustre file system. For the many-to-one pattern, we find that data\ntransport becomes a dominant bottleneck as the ensemble size grows. Our\nevaluation reveals that file system is the optimal solution among the tested\nstrategies for the many-to-one pattern."}
{"id": "2509.19187", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2509.19187", "abs": "https://arxiv.org/abs/2509.19187", "authors": ["Jérémie Chalopin", "Yi-Jun Chang", "Lyuting Chen", "Giuseppe A. Di Luna", "Haoran Zhou"], "title": "Non-Uniform Content-Oblivious Leader Election on Oriented Asynchronous Rings", "comment": null, "summary": "We study the leader election problem in oriented ring networks under\ncontent-oblivious asynchronous message-passing systems, where an adversary may\narbitrarily corrupt message contents.\n  Frei et al. (DISC 2024) presented a uniform terminating leader election\nalgorithm for oriented rings in this setting, with message complexity $O(n\n\\cdot \\mathsf{ID}_{\\max})$ on a ring of size $n$, where $\\mathsf{ID}_{\\max}$ is\nthe largest identifier in the system, this result has been recently extended by\nChalopin et al. (DISC 2025) to unoriented rings.\n  In this paper, we investigate the message complexity of leader election on\nring networks in the content-oblivious model, showing that no uniform algorithm\ncan solve the problem if each process is limited to sending a constant number\nof messages in one direction.\n  Interestingly, this limitation hinges on the uniformity assumption. In the\nnon-uniform setting, where processes know an upper bound $U \\geq n$ on the ring\nsize, we present an algorithm with message complexity $O(n \\cdot U \\cdot\n\\mathsf{ID}_{\\min})$, in which each process sends $O(U \\cdot\n\\mathsf{ID}_{\\min})$ messages clockwise and only three messages\ncounter-clockwise. Here, $\\mathsf{ID}_{\\min}$ is the smallest identifier in the\nsystem. This dependence on the identifiers compares favorably with the\ndependence on $\\mathsf{ID}_{\\max}$ of Frei et al.\n  We also show a non-uniform algorithm where each process sends $O(U \\cdot\n\\log\\mathsf{ID}_{\\min})$ messages in one direction and\n$O(\\log\\mathsf{ID}_{\\min})$ in the other. The factor $\\log \\mathsf{ID}_{\\min}$\nis optimal, matching the lower bound of Frei et al.\n  Finally, in the anonymous setting, where processes do not have identifiers,\nwe propose a randomized algorithm where each process sends only $O(\\log^2 U)$\nmessages, with a success probability of $1 - U^{-c}$."}
{"id": "2509.19294", "categories": ["cs.DC", "astro-ph.IM", "D.1.3; J.2"], "pdf": "https://arxiv.org/pdf/2509.19294", "abs": "https://arxiv.org/abs/2509.19294", "authors": ["Jenny Lynn Almerol", "Elisabetta Boella", "Mario Spera", "Daniele Gregori"], "title": "Accelerating Gravitational $N$-Body Simulations Using the RISC-V-Based Tenstorrent Wormhole", "comment": null, "summary": "Although originally developed primarily for artificial intelligence\nworkloads, RISC-V-based accelerators are also emerging as attractive platforms\nfor high-performance scientific computing. In this work, we present our\napproach to accelerating an astrophysical $N$-body code on the RISC-V-based\nWormhole n300 card developed by Tenstorrent. Our results show that this\nplatform can be highly competitive for astrophysical simulations employing this\nclass of algorithms, delivering more than a $2 \\times$ speedup and\napproximately $2 \\times$ energy savings compared to a highly optimized CPU\nimplementation of the same code."}
